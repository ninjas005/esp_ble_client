#include <Arduino.h>
#include <NimBLEDevice.h>
#include <WiFi.h>
#include <ArduinoJson.h>
#include <Preferences.h>
#include <HTTPClient.h>
#include <WiFiClientSecure.h>
#include <time.h>
#include <ModbusMaster.h>

#include <SD.h>
#include <SPI.h>
#include <FS.h>

#define SERVICE_UUID        "204fefb3-3d9b-4e3f-8f76-8245e29ac6e9"
#define CHAR_UUID_WRITE     "c639bc5a-c5fa-48e4-814b-257a2cfc425e"
#define CHAR_UUID_NOTIFY    "63b05182-23a1-43e7-855b-a85cf8f7b7fb"
#define RX1_PIN 18
#define TX1_PIN 17

#define SD_CS_PIN 5

Preferences preferences;
NimBLECharacteristic* pNotifyCharacteristic = NULL;
ModbusMaster modbus;

bool deviceConnected = false;
bool triggerWifiScan = false;
bool wifiConfigReceived = false;
bool watchdogPaused = false;
bool forceHttpNow = false;

float setPoint1 = 0.0;
float setPoint2 = 0.0;

unsigned long lastFileCheckTime = 0;

String targetSSID = "";
String targetPass = "";

// Config Variables
String DEVICE_ID = "ESP_001";
String API_URL = "https://cloudbases.in/iot_demo24/Api";
String NTP_SERVER = "1.in.pool.ntp.org";
int UPDATE_INTERVAL = 60; // Stored in Seconds
int UPDATE_MODE = 0;      // 0 = Interval (Timer), 1 = Clock Aligned (Cron)

unsigned long lastHttpTime = 0;
unsigned long lastWatchdogTime = 0;
int lastClockMinute = -1; // To prevent double sending in the same minute
const unsigned long WATCHDOG_TIMEOUT = 10000;

typedef enum {
    PROCESS_VALUE = 0,
    DECIMAL_POINT = 1,
    SET_POINT_1 = 2,
    SET_POINT_2 = 3,
    LOW_ALARM_STATUS = 4,
    HIGH_ALARM_STATUS = 5
} SensorAddress;

// ----------------------------------------------------------------
// HELPERS
// ----------------------------------------------------------------

void setupSD() {
    Serial.print(">> SD: Initializing... ");
    // If you use custom SPI pins, use SPI.begin(SCK, MISO, MOSI, SS); first
    if (!SD.begin(SD_CS_PIN)) {
        Serial.println("Failed!");
    } else {
        Serial.println("Success.");
    }
}

void saveDataOffline(String timestamp, String sensorData) {
    if(!SD.begin(SD_CS_PIN)) return; // Safety check

    // Create filename: /YYYYMMDDHHMMSS.txt
    String filename = "/" + timestamp; 
    filename.replace(" ", ""); 
    filename.replace("-", ""); 
    filename.replace(":", "");
    filename += ".txt";

    // Format: Timestamp,Value
    String content = timestamp + "," + sensorData + "\n";

    File file = SD.open(filename, FILE_WRITE);
    if(file) {
        file.print(content);
        file.close();
        Serial.println(">> SD: Saved offline -> " + filename);
    } else {
        Serial.println(">> SD: Error writing file");
    }
}

void processOfflineFiles() {
    if (WiFi.status() != WL_CONNECTED) return;

    File root = SD.open("/");
    if(!root) return;

    File file = root.openNextFile();
    while(file) {
        String filename = String(file.name());
        if(!filename.startsWith("/")) filename = "/" + filename;

        if(filename.endsWith(".txt")) {
            Serial.println(">> SD: Processing " + filename);
            
            String content = file.readStringUntil('\n');
            content.trim();
            file.close(); 

            int commaIndex = content.indexOf(',');
            if (commaIndex > 0) {
                String ts = content.substring(0, commaIndex);
                String val = content.substring(commaIndex + 1);
                
                String fullUrl = API_URL + "?device_code=" + DEVICE_ID + "&field1=" + val + "&timestamp=" + ts;
                fullUrl.replace(" ", "%20"); 

                HTTPClient http;
                WiFiClientSecure client; 
                client.setInsecure();
                http.begin(client, fullUrl); 
                
                int code = http.GET();
                String response = http.getString();
                http.end();

                // Check for "true" in response (based on your API requirement)
                if (code == 200 && response.indexOf("true") >= 0) {
                    Serial.println(">> SD: Upload Success. Deleting file.");
                    SD.remove(filename);
                } else {
                    Serial.println(">> SD: Upload Failed. Retrying later.");
                    return; 
                }
            } else {
                SD.remove(filename); // Delete corrupt files
            }
        }
        file = root.openNextFile();
    }
}

void loadConfig() {
    preferences.begin("app_conf", true);
    if(preferences.isKey("data")) {
        String json = preferences.getString("data", "{}");
        JsonDocument doc;
        deserializeJson(doc, json);
        
        if(doc.containsKey("id")) DEVICE_ID = doc["id"].as<String>();
        if(doc.containsKey("url")) API_URL = doc["url"].as<String>();
        if(doc.containsKey("ntp")) NTP_SERVER = doc["ntp"].as<String>();
        if(doc.containsKey("int")) UPDATE_INTERVAL = doc["int"].as<int>();
        if(doc.containsKey("mode")) UPDATE_MODE = doc["mode"].as<int>();

        if(doc.containsKey("sp1")) setPoint1 = doc["sp1"].as<float>();
        if(doc.containsKey("sp2")) setPoint2 = doc["sp2"].as<float>();
        
        if(UPDATE_INTERVAL < 1) UPDATE_INTERVAL = 1; 
        Serial.println(">> CONFIG: Loaded.");
    }
    preferences.end();
}

void saveConfig() {
    preferences.begin("app_conf", false);
    JsonDocument doc;
    doc["id"] = DEVICE_ID;
    doc["url"] = API_URL;
    doc["ntp"] = NTP_SERVER;
    doc["int"] = UPDATE_INTERVAL;
    doc["mode"] = UPDATE_MODE;

    doc["sp1"] = setPoint1;
    doc["sp2"] = setPoint2;

    String output;
    serializeJson(doc, output);
    preferences.putString("data", output);
    preferences.end();
    Serial.println(">> CONFIG: Saved to NVS.");
}

void saveNetworkToMemory(String ssid, String pass) {
    if(ssid.length() == 0) return;
    preferences.begin("wifi_db", false);
    String currentData = preferences.getString("nets", "[]");
    JsonDocument doc;
    deserializeJson(doc, currentData);
    JsonArray array = doc.as<JsonArray>();
    bool found = false;
    for (JsonObject obj : array) {
        if (obj["s"] == ssid) {
            obj["p"] = pass; found = true; break;
        }
    }
    if (!found) {
        while (array.size() >= 5) array.remove(0);
        JsonObject newObj = array.add<JsonObject>();
        newObj["s"] = ssid; newObj["p"] = pass;
    }
    String output;
    serializeJson(doc, output);
    preferences.putString("nets", output);
    preferences.end();
}

bool tryAutoConnect() {
    Serial.println(">> AUTO: Scanning...");
    int n = WiFi.scanNetworks();
    if (n == 0) return false;

    preferences.begin("wifi_db", true);
    String savedData = preferences.getString("nets", "[]");
    preferences.end();
    if (savedData == "[]") return false;

    JsonDocument doc;
    deserializeJson(doc, savedData);
    JsonArray savedNets = doc.as<JsonArray>();

    for (int i = 0; i < n; ++i) {
        String currentSSID = WiFi.SSID(i);
        for (JsonObject obj : savedNets) {
            if (obj["s"] == currentSSID) {
                String savedPass = obj["p"].as<String>();
                Serial.printf(">> AUTO: Connecting to %s\n", currentSSID.c_str());
                WiFi.begin(currentSSID.c_str(), savedPass.c_str());
                int attempts = 0;
                while (WiFi.status() != WL_CONNECTED && attempts < 20) {
                    delay(500); Serial.print("."); attempts++;
                }
                Serial.println();
                if (WiFi.status() == WL_CONNECTED) return true;
            }
        }
    }
    return false;
}

// ----------------------------------------------------------------
// HTTP & SENSOR
// ----------------------------------------------------------------
void setupTime() {
    configTime(0, 0, NTP_SERVER.c_str());
    Serial.println(">> TIME: Syncing...");
}


void setupModbus() {
    modbus.begin(1, Serial1);  // Slave ID 1 on Serial1
    // modbus.BaudRate(9600);     // Set baud rate
    Serial.println(">> MODBUS: Initialized");
}


uint8_t writeModbusRegister(uint16_t reg, uint16_t value) {
    uint8_t wResult = modbus.writeSingleRegister(reg, value);
    if (wResult == modbus.ku8MBSuccess) {
        Serial.println(">> MODBUS: write OK");
        return 1;
    } else {
        Serial.printf(">> MODBUS: write error: %02X\n", wResult);
        return 0;
    }
}   


void sendSensorData() {
    if (WiFi.status() != WL_CONNECTED) return;
    // 1. READ DATA
    String sensorData = "0";
    if (Serial1.available()) {
        sensorData = Serial1.readStringUntil('\n');
        sensorData.trim();
    }
    
    // Modbus Read 
    uint8_t result = modbus.readHoldingRegisters(PROCESS_VALUE, 2);
    if (result == modbus.ku8MBSuccess) {
        uint16_t sensorValue = modbus.getResponseBuffer(0);
        sensorData = String(sensorValue);
        Serial.println(">> SENSOR: " + sensorData + " (Modbus)");
    } 

    if (sensorData == "" || sensorData == "0") {
        Serial.println(">> SKIP: Timer triggered, but Sensor Data is 0 or Empty.");
        
        // UNCOMMENT THIS LINE TO FORCE DUMMY DATA FOR TESTING:
        // sensorData = "99.9"; Serial.println(">> TEST MODE: Sending Dummy Data 99.9");
        
        if (sensorData == "0") return; // Only return if we didn't inject dummy data
    }

    lastWatchdogTime = millis(); 

    // 2. GET TIMESTAMP
    time_t now;
    time(&now);
    struct tm timeinfo;
    localtime_r(&now, &timeinfo);
    char timeStr[25];
    strftime(timeStr, sizeof(timeStr), "%Y-%m-%d %H:%M:%S", &timeinfo);

    // 3. SEND OR SAVE
    if (WiFi.status() == WL_CONNECTED) {
        // --- ONLINE MODE ---
        Serial.println(">> HTTP: Sending data...");
        
        String fullUrl = API_URL + "?device_code=" + DEVICE_ID + "&field1=" + sensorData + "&timestamp=" + String(now);
        fullUrl.replace(" ", "%20");

        WiFiClientSecure client;
        client.setInsecure();
        client.setTimeout(5000); 

        HTTPClient http;
        http.begin(client, fullUrl);
        int httpResponseCode = http.GET();
        String response = http.getString(); // Get response to check for "true"
        http.end();

        Serial.print(">> HTTP Status: ");
        Serial.println(httpResponseCode);
        Serial.print(">> HTTP Body: ");
        Serial.println(response);
        
        // CHECK IF UPLOAD WAS ACTUALLY SUCCESSFUL
        if (httpResponseCode == 200 && response.indexOf("true") >= 0) {
             Serial.printf(">> HTTP: Success (%d)\n", httpResponseCode);
        } else {
             Serial.printf(">> HTTP: Failed (%d). Saving to SD...\n", httpResponseCode);
             saveDataOffline(String(timeStr), sensorData); // <--- FALLBACK SAVE
        }

    } else {
        // --- OFFLINE MODE ---
        Serial.println(">> WIFI: Disconnected. Saving to SD...");
        saveDataOffline(String(timeStr), sensorData); // <--- OFFLINE SAVE
    }
}

// ----------------------------------------------------------------
// CALLBACKS
// ----------------------------------------------------------------
class MyServerCallbacks: public NimBLEServerCallbacks {
    void onConnect(NimBLEServer* pServer) {
        deviceConnected = true;
        lastWatchdogTime = millis();
        Serial.println(">> EVENT: Phone Connected");
    };
    void onDisconnect(NimBLEServer* pServer) {
        deviceConnected = false;
        Serial.println(">> EVENT: Phone Disconnected");
        NimBLEDevice::startAdvertising();
    }
};

class MyCallbacks: public NimBLECharacteristicCallbacks {
    void onWrite(NimBLECharacteristic *pCharacteristic) {
        std::string value = pCharacteristic->getValue();
        if (value.length() > 0) {
            lastWatchdogTime = millis();
            
            Serial.print(">> RAW BLE: ");
            Serial.println(value.c_str());

            JsonDocument doc;
            DeserializationError error = deserializeJson(doc, value);
            
            if (!error) {
                if (doc.containsKey("action")) {
                    const char* act = doc["action"];
                    if (strcmp(act, "scan") == 0) triggerWifiScan = true;
                    else if (strcmp(act, "get_conf") == 0) {
                        JsonDocument resp;
                        resp["id"] = DEVICE_ID;
                        resp["url"] = API_URL;
                        resp["ntp"] = NTP_SERVER;
                        resp["int"] = UPDATE_INTERVAL;
                        resp["mode"] = UPDATE_MODE;
                        resp["sp1"] = setPoint1; // Add these
                        resp["sp2"] = setPoint2;
                         String out;
                         serializeJson(resp, out);
                         if(deviceConnected) {
                             pNotifyCharacteristic->setValue(out);
                             pNotifyCharacteristic->notify();
                         }
                    }
                    else if (strcmp(act, "get_status") == 0) {
                         String statusMsg = "Status: Not Connected";
                         if (WiFi.status() == WL_CONNECTED) statusMsg = "Connected! SSID: " + WiFi.SSID() + " | IP: " + WiFi.localIP().toString();
                         if(deviceConnected) { pNotifyCharacteristic->setValue(statusMsg); pNotifyCharacteristic->notify(); }
                    }
                }
                // UPDATE CONFIG
                else if (
                    doc.containsKey("id") || 
                    doc.containsKey("url") || 
                    doc.containsKey("ntp") || 
                    doc.containsKey("int") || 
                    doc.containsKey("mode") || 
                    doc.containsKey("sp1") ||
                    doc.containsKey("sp2")
                ) {
                    bool changed = false;
                    if(doc.containsKey("id")) { DEVICE_ID = doc["id"].as<String>(); changed = true; }
                    if(doc.containsKey("url")) { API_URL = doc["url"].as<String>(); changed = true; }
                    if(doc.containsKey("ntp")) { NTP_SERVER = doc["ntp"].as<String>(); changed = true; }
                    if(doc.containsKey("int")) { UPDATE_INTERVAL = doc["int"].as<int>(); changed = true; }
                    if(doc.containsKey("mode")) { UPDATE_MODE = doc["mode"].as<int>(); changed = true; }
                    if(doc.containsKey("sp1")) { setPoint1 = doc["sp1"].as<float>(); changed = true; }
                    if(doc.containsKey("sp2")) { setPoint2 = doc["sp2"].as<float>(); changed = true; }

                    if(changed) {
                        saveConfig();
                        forceHttpNow = true; 
                        if(deviceConnected) {
                            pNotifyCharacteristic->setValue("Settings Saved.");
                            pNotifyCharacteristic->notify();
                        }
                    }
                }
                else if (doc.containsKey("ssid")) {
                    targetSSID = String((const char*)doc["ssid"]);
                    targetPass = String((const char*)doc["pass"]);
                    targetSSID.trim(); targetPass.trim();
                    wifiConfigReceived = true;
                }
            }
        }
    }
};

// ----------------------------------------------------------------
// SETUP
// ----------------------------------------------------------------
void setup() {
    Serial.begin(115200);
    Serial.setTimeout(50); 
    Serial1.begin(9600, SERIAL_8N1, RX1_PIN, TX1_PIN);
    Serial1.setTimeout(50); 
    setupSD();

    delay(2000);
    Serial.println("--- FIRMWARE STARTED ---");

    preferences.begin("wifi_db", false);
    if (!preferences.isKey("nets")) preferences.putString("nets", "[]");
    preferences.end();
    
    loadConfig();

    uint64_t mac = ESP.getEfuseMac();
    uint32_t lowBytes = (uint32_t)mac; 
    String devName = "ESP_Setup_" + String(lowBytes, HEX);
    devName.toUpperCase();
    Serial.println("Device Name: " + devName);
    
    NimBLEDevice::init(devName.c_str()); 

    NimBLEDevice::setPower(ESP_PWR_LVL_P9);
    NimBLEDevice::setMTU(250);

    NimBLEServer* pServer = NimBLEDevice::createServer();
    pServer->setCallbacks(new MyServerCallbacks());
    NimBLEService *pService = pServer->createService(SERVICE_UUID);
    
    NimBLECharacteristic *pWriteCharacteristic = pService->createCharacteristic(
        CHAR_UUID_WRITE, NIMBLE_PROPERTY::WRITE | NIMBLE_PROPERTY::WRITE_NR
    );
    pWriteCharacteristic->setCallbacks(new MyCallbacks());
    
    pNotifyCharacteristic = pService->createCharacteristic(
        CHAR_UUID_NOTIFY, NIMBLE_PROPERTY::READ | NIMBLE_PROPERTY::NOTIFY
    );
    
    pService->start();
    NimBLEAdvertising *pAdvertising = NimBLEDevice::getAdvertising();
    pAdvertising->addServiceUUID(SERVICE_UUID);
    
    NimBLEAdvertisementData scanResp;
    scanResp.setName(devName.c_str());
    pAdvertising->setScanResponseData(scanResp);
    
    pAdvertising->start();
    
    lastWatchdogTime = millis();

    WiFi.mode(WIFI_STA);
    WiFi.disconnect();
    delay(100);
    
    setupModbus();
    
    if (tryAutoConnect()) {
        Serial.println(">> BOOT: Connected.");
        setupTime();
    }
}

// ----------------------------------------------------------------
// LOOP
// ----------------------------------------------------------------
void loop() {
    if (deviceConnected && !watchdogPaused && (millis() - lastWatchdogTime > WATCHDOG_TIMEOUT)) {
         Serial.println(">> WATCHDOG: App died. Force Disconnect.");
         NimBLEDevice::getServer()->disconnect(0); 
    }

    if (WiFi.status() == WL_CONNECTED && (millis() - lastFileCheckTime > 900000)) {
        lastFileCheckTime = millis();
        processOfflineFiles();
    }

    if (WiFi.status() == WL_CONNECTED) {
        
        bool shouldTrigger = false;

        // MODE 0: INTERVAL (Standard Timer)
        if (UPDATE_MODE == 0) {
            if (millis() - lastHttpTime > (UPDATE_INTERVAL * 1000)) {
                shouldTrigger = true;
                lastHttpTime = millis();
            }
        }
        // MODE 1: CLOCK ALIGNED (Cron)
        else if (UPDATE_MODE == 1) {
            struct tm timeinfo;
            if (getLocalTime(&timeinfo)) {
                int minInterval = UPDATE_INTERVAL / 60;
                if (minInterval < 1) minInterval = 1;

                if (timeinfo.tm_min % minInterval == 0 && timeinfo.tm_min != lastClockMinute) {
                    shouldTrigger = true;
                    lastClockMinute = timeinfo.tm_min;
                }
            }
        }

        if (forceHttpNow) {
            shouldTrigger = true;
            forceHttpNow = false;
        }

        if (shouldTrigger) {
            sendSensorData();
        }
    }

    if (triggerWifiScan) {
        triggerWifiScan = false;
        watchdogPaused = true; 
        
        if(deviceConnected) { pNotifyCharacteristic->setValue("Scanning..."); pNotifyCharacteristic->notify(); }
        
        WiFi.disconnect(); 
        int n = WiFi.scanNetworks();
        JsonDocument scanDoc; JsonArray array = scanDoc.to<JsonArray>();
        for (int i = 0; i < n && i < 15; ++i) { if(WiFi.SSID(i).length() > 0) array.add(WiFi.SSID(i)); }
        String output; serializeJson(scanDoc, output);
        if(deviceConnected) { pNotifyCharacteristic->setValue(output); pNotifyCharacteristic->notify(); }
        WiFi.scanDelete();
        watchdogPaused = false; lastWatchdogTime = millis(); 
    }

    if (wifiConfigReceived) {
        wifiConfigReceived = false;
        watchdogPaused = true;
        if(deviceConnected) { pNotifyCharacteristic->setValue("Connecting..."); pNotifyCharacteristic->notify(); }
        WiFi.disconnect(); WiFi.begin(targetSSID.c_str(), targetPass.c_str());
        int attempts = 0; while (WiFi.status() != WL_CONNECTED && attempts < 20) { delay(500); Serial.print("."); attempts++; }
        Serial.println();
        if (WiFi.status() == WL_CONNECTED) {
            String msg = "Connected! SSID: " + WiFi.SSID() + " | IP: " + WiFi.localIP().toString();
            Serial.println(msg);
            if(deviceConnected) { pNotifyCharacteristic->setValue(msg); pNotifyCharacteristic->notify(); }
            saveNetworkToMemory(targetSSID, targetPass);
            setupTime();
            forceHttpNow = true;
        } else {
            Serial.println(">> ERROR: Connect Failed");
            if(deviceConnected) { pNotifyCharacteristic->setValue("Connection Failed."); pNotifyCharacteristic->notify(); }
        }
        watchdogPaused = false; lastWatchdogTime = millis();
    }
    
    static unsigned long lastWifiCheck = 0;
    if (WiFi.status() != WL_CONNECTED && !deviceConnected && (millis() - lastWifiCheck > 10000)) {
        lastWifiCheck = millis(); tryAutoConnect();
    }

    delay(10); 
}